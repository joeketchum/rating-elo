<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>The Rating Game</title>
  <style>
    body { font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; margin: 0; padding: 0; }
    #elm { min-height: 100vh; }
    .toast { position: fixed; right: 16px; bottom: 16px; background: rgba(0,0,0,0.85); color: white; padding: 8px 12px; border-radius: 6px; font-size: 13px; box-shadow: 0 6px 18px rgba(0,0,0,0.15); z-index: 9999; opacity: 0; transform: translateY(8px); transition: opacity 200ms, transform 200ms; }
    .toast.show { opacity: 1; transform: translateY(0); }
  </style>
</head>
<body>
  <div id="elm"></div>

  <script src="./elm.js"></script>
  <script>
    (function () {
      // LocalStorage keys
      const STANDINGS_KEY = 'rating-elo.standings';
      const AUTOSAVE_KEY = 'rating-elo.autosave';
      const PUBLIC_COPY_KEY = 'rating-elo.public_copy';

  // Configure this to your Apps Script Web App URL if you want server-side persistence.
  // If left empty, the host will only save a local copy (no network upload).
  const SAVE_URL = 'https://script.google.com/macros/s/AKfycbxc5UWCVkDzwOy2MwkHpxkPb8H6PIoVIPQRSw72wRyIHdTBaUi81TvDglWpVEeP79VKiw/exec';

      function toastElem() { const el = document.createElement('div'); el.className = 'toast'; document.body.appendChild(el); let t=null; return { show(msg, ms=3000){ el.textContent=msg; el.classList.add('show'); clearTimeout(t); t=setTimeout(()=>el.classList.remove('show'),ms); } }; }
      const toast = toastElem();

      async function uploadToAppsScript(jsonText) {
        if (!SAVE_URL) {
          return { ok: false, reason: 'no-save-url' };
        }
        try {
          const res = await fetch(SAVE_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: jsonText
          });
          if (!res.ok) {
            return { ok: false, reason: 'http:' + res.status };
          }
          return { ok: true, status: res.status };
        } catch (err) {
          return { ok: false, reason: err && err.message ? err.message : String(err) };
        }
      }

      function wire(app){
        if (!app || !app.ports) return;

        if (app.ports.saveStandings) {
          app.ports.saveStandings.subscribe(json => {
            try { localStorage.setItem(STANDINGS_KEY, json); toast.show('Saved to localStorage'); }
            catch (e) { console.error(e); toast.show('Save failed'); }
          });
        }

        if (app.ports.askForStandings && app.ports.receiveStandings) {
          app.ports.askForStandings.subscribe(() => {
            const s = localStorage.getItem(STANDINGS_KEY) || '';
            app.ports.receiveStandings.send(s);
          });
        }

        if (app.ports.saveAutoSave) {
          app.ports.saveAutoSave.subscribe(v => {
            try { localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(!!v)); }
            catch (e) { console.error(e); }
          });
        }

        if (app.ports.askForAutoSave && app.ports.receiveAutoSave) {
          app.ports.askForAutoSave.subscribe(() => {
            const raw = localStorage.getItem(AUTOSAVE_KEY);
            const val = raw === null ? false : (raw === 'true');
            app.ports.receiveAutoSave.send(val);
          });
        }

        // saveToPublicDrive: attempt server upload when SAVE_URL is set, otherwise fall back to local save
        if (app.ports.saveToPublicDrive) {
          app.ports.saveToPublicDrive.subscribe(async (json) => {
            // Always keep a local copy so users have a fallback
            try { localStorage.setItem(PUBLIC_COPY_KEY, json); }
            catch (e) { console.error('local save error', e); }

            if (!SAVE_URL) {
              if (app.ports.receivePublicDriveStatus) app.ports.receivePublicDriveStatus.send('saved-local|' + new Date().toISOString());
              toast.show('Saved public copy (local)');
              return;
            }

            // Try uploading
            const result = await uploadToAppsScript(json);
            if (result.ok) {
              const ts = new Date().toISOString();
              if (app.ports.receivePublicDriveStatus) app.ports.receivePublicDriveStatus.send('saved-drive|' + ts);
              toast.show('Saved to Drive');
            } else {
              console.error('upload failed', result);
              if (app.ports.receivePublicDriveStatus) app.ports.receivePublicDriveStatus.send('error|' + result.reason);
              toast.show('Drive save failed');
            }
          });
        }

        if (app.ports.loadFromPublicDrive && app.ports.receiveStandings) {
          app.ports.loadFromPublicDrive.subscribe(() => {
            const j = localStorage.getItem(PUBLIC_COPY_KEY) || '';
            app.ports.receiveStandings.send(j);
            toast.show('Loaded public copy (local)');
          });
        }
      }

      function start(){ if(typeof Elm==='undefined' || !Elm.Main) return setTimeout(start,50); try{ const app = Elm.Main.init({ node: document.getElementById('elm') }); wire(app); }catch(e){ console.error('Elm init failed', e); const h=document.createElement('h1'); h.style.fontFamily='monospace'; h.innerText='Initialization Error'; const pre=document.getElementById('elm'); document.body.insertBefore(h,pre); pre.innerText=String(e); } }
      start();
    })();
  </script>
</body>
</html>
